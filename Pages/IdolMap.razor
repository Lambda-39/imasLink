@page "/"
@using System.Text.Json
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<div class="theater-container">
    @if (_isLoading)
    {
        @* 演出：開演前のカーテン（ローディング）ですわ *@
        <div class="loading-overlay">
            <div class="spinner"></div>
            <p>ローディング中……</p>
        </div>
    }

    <div class="control-panel">
        <h3>アイドル相関図</h3>
        <div class="controls">
            <div class="control-group">
                <label>ブランド：</label>
                <select @onchange="OnFilterChanged" class="form-select w-auto d-inline">
                    <option value="All">全て表示</option>
                    <option value="MutualOnly">双方向のみ</option>
                    @foreach (var brand in Brands)
                    {
                        <option value="@brand">@brand</option>
                    }
                </select>
            </div>
            <div class="control-group">
                <label>名前で検索：</label>
                @* 演出：入力するたびに即座に反応いたしますわ *@
                <input type="text" @oninput="OnSearchInput" class="form-control w-auto d-inline" placeholder="アイドル名を入力..." />
            </div>
            <div class="control-group">
                <button class="btn btn-outline-primary ms-2" @onclick="RerunLayout">
                    ランダムに再配置
                </button>
            </div>
            <div class="control-group">
                <label>表示モード：</label>
                <select @onchange="OnModeChanged" class="form-select w-auto d-inline">
                    <option value="Standard">通常モード</option>
                    <option value="InterBrand">同ブランド同士を非表示</option>
                </select>
            </div>
            <div class="source-credit">
                ソース：<a href="https://idollist.idolmaster-official.jp/" target="_blank" rel="noopener noreferrer">アイドル名鑑</a>（2025/12月時点）
            </div>
        </div>
        
    </div>

    <div id="cy"></div>
</div>

@code {
    private List<IdolData> AllIdols = new();
    private List<string> Brands = new();
    private bool _isLoading = true;
    private bool _isGraphDrawn = false;

    private string _currentMode = "Standard";
    private string _selectedBrand = "All";

    protected override async Task OnInitializedAsync()
    {
        AllIdols = await Http.GetFromJsonAsync<List<IdolData>>("data/idols.json") ?? new();
        Brands = AllIdols.Select(i => i.Brand).Distinct().ToList();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (AllIdols.Any() && !_isGraphDrawn)
        {
            _isGraphDrawn = true;
            await RenderGraph();
            _isLoading = false; // 描画命令を出した後にカーテンを開けますわ
            StateHasChanged();
        }
    }

    private async Task RenderGraph()
    {
        var existingIdSet = new HashSet<string>(AllIdols.Select(i => i.Id));
        var nodes = AllIdols.Select(i => new { data = new { id = i.Id, name = i.Name, brand = i.Brand, image = $"images/idols/{i.Id}.jpg" } });
        var edges = new List<object>();
        var linkLookup = new HashSet<(string, string)>(AllIdols.SelectMany(i => i.RelatedIds.Select(r => (i.Id, r))));

        foreach (var idol in AllIdols)
        {
            foreach (var targetId in idol.RelatedIds)
            {
                if (!existingIdSet.Contains(targetId)) continue;
                bool isMutual = linkLookup.Contains((targetId, idol.Id));
                if (isMutual && string.Compare(idol.Id, targetId) > 0) continue;

                edges.Add(new
                {
                    data = new { source = idol.Id, target = targetId },
                    classes = isMutual ? "mutual" : ""
                });
            }
        }
        await JSRuntime.InvokeVoidAsync("initIdolGraph", new { nodes, edges });
    }

    private async Task OnFilterChanged(ChangeEventArgs e)
    {
        _selectedBrand = e.Value?.ToString() ?? "All";
        await ApplyCurrentFilter();
    }

    private async Task OnModeChanged(ChangeEventArgs e)
    {
        _currentMode = e.Value?.ToString() ?? "Standard";
        await ApplyCurrentFilter();
    }

    private async Task ApplyCurrentFilter()
    {
        if (_currentMode == "InterBrand" && _selectedBrand != "All" && _selectedBrand != "MutualOnly")
        {
            // 新しい「架け橋」フィルターを呼び出しますわ
            await JSRuntime.InvokeVoidAsync("applyIncomingInterBrandFilter", _selectedBrand);
        }
        else
        {
            // 通常のフィルターですわ
            await JSRuntime.InvokeVoidAsync("applyBrandFilter", _selectedBrand);
        }
    }

    private async Task OnSearchInput(ChangeEventArgs e)
    {
        // 演出：JavaScript側に名前を伝え、ハイライトさせますわ
        await JSRuntime.InvokeVoidAsync("searchAndHighlight", e.Value?.ToString());
    }

    private async Task RerunLayout()
    {
        // 先ほど作成した JavaScript の関数を呼び出しますわ
        await JSRuntime.InvokeVoidAsync("rerunLayout");
    }
}